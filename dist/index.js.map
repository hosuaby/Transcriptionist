{"version":3,"file":"index.js","sources":["../node_modules/@commander-js/extra-typings/index.js","../node_modules/@commander-js/extra-typings/esm.mjs","../src/cli.ts","../src/audio-extractor.ts","../src/work-dir.ts","../src/transcriber.ts","../src/captions.ts","../src/nlp.ts","../src/corrector.ts","../src/words-spans-validator.ts","../src/nlp/clauses-words-clusterer.ts","../src/nlp/sentences-words-clusterer.ts","../src/nlp/max-length-words-clusterer.ts","../src/nlp/words-clusterer.ts","../src/index.ts"],"sourcesContent":["const commander = require('commander');\n\nexports = module.exports = {};\n\n// Return a different global program than commander,\n// and don't also return it as default export.\nexports.program = new commander.Command();\n\n/**\n * Expose classes. The FooT versions are just types, so return Commander original implementations!\n */\n\nexports.Argument = commander.Argument;\nexports.Command = commander.Command;\nexports.CommanderError = commander.CommanderError;\nexports.Help = commander.Help;\nexports.InvalidArgumentError = commander.InvalidArgumentError;\nexports.InvalidOptionArgumentError = commander.InvalidArgumentError; // Deprecated\nexports.Option = commander.Option;\n\n// In Commander, the create routines end up being aliases for the matching\n// methods on the global program due to the (deprecated) legacy default export.\n// Here we roll our own, the way Commander might in future.\nexports.createCommand = (name) => new commander.Command(name);\nexports.createOption = (flags, description) =>\n  new commander.Option(flags, description);\nexports.createArgument = (name, description) =>\n  new commander.Argument(name, description);\n","import extraTypingsCommander from './index.js';\n\n// wrapper to provide named exports for ESM.\nexport const {\n  program,\n  createCommand,\n  createArgument,\n  createOption,\n  CommanderError,\n  InvalidArgumentError,\n  InvalidOptionArgumentError, // deprecated old name\n  Command,\n  Argument,\n  Option,\n  Help,\n} = extraTypingsCommander;\n","import * as path from 'path';\nimport {Command, Option} from '@commander-js/extra-typings';\nimport packageJson from '../package.json';\n\nexport interface Args {\n    videoInputFile: string;\n    srtOutputFile: string;\n    teleprompterFile?: string\n    locale: string;\n    maxWordsPerCaption: number;\n    splitBySentences: boolean;\n    splitByClauses: boolean;\n    karaokeEnabled: boolean;\n}\n\nfunction assertFileExtension(ext: string): (v: string) => void {\n    return (value: string) => {\n        if (!value.endsWith(ext)) {\n            throw new Error(`File should have extension ${ext}!`);\n        }\n        return value;\n    };\n}\n\nfunction parseIntAndAssert(...assertions: ((v: number) => void)[]): (v: string) => number {\n    return (value: string) => {\n        const int = parseInt(value, 10);\n        assertions.forEach(assertion => assertion(int));\n        return int;\n    }\n}\n\nfunction assertPositive(option: string): (v: number) => void {\n    return (value: number) => {\n        if (value < 0) {\n            throw new Error(`${option} should be positive!`);\n        }\n    };\n}\n\nconst program = new Command();\n\nprogram\n    .name('transcribe')\n    .description('Tool to transcribe videos using AI.')\n    .version(packageJson.version)\n    .argument('<file>', 'Path to the original video file.')\n    .option('-o, --output <file>',\n        'Full or relative path where the created SubRip Subtitle (.srt) file should be written. ' +\n        'By default, it will be saved in the same directory as the input video file.',\n        assertFileExtension('.srt'))\n    .option('-t, --teleprompt <file>',\n        'Full or relative path to teleprompter text (.txt) file. ' +\n        'If not provided, transcription will not be corrected.',\n        assertFileExtension('.txt'))\n    .option('-l, --locale <string>',\n        'Locale that will be used to transcribe the video.',\n        'en-US')\n    .option('-n, --length <number>',\n        'Maximum number of words per caption.',\n        parseIntAndAssert(assertPositive('Max caption length')),\n        5)\n    .addOption(new Option('-s, --sentences',\n        'Split produced text by sentences, instead of defined number of words. ' +\n        'A sentence is defined to be a unit of text that ends with a sentence boundary marker ' +\n        '(period, question mark, exclamation mark). ' +\n        'If this option is provided, maximum number of words per caption is ignored.')\n        .conflicts([ 'clauses' ]))\n    .addOption(new Option('-c, --clauses',\n        'Split produced text by clauses, instead of defined number of words. ' +\n        'A clause is defined to be a meaningful unit of a sentence that typically contains a subject and a verb phrase. ' +\n        'If this option is provided, maximum number of words per caption is ignored.')\n        .conflicts([ 'sentences' ]))\n    .option('-k, --karaoke',\n        'Enables Karaoke-style captioning supported by PupCaps.')\n    .action((inputFile, options: any) => {\n        const absoluteInputFile = path.resolve(inputFile);\n        program.args[0] = absoluteInputFile;\n\n        if (!options.output) {\n            const outputDir = path.dirname(absoluteInputFile);\n            const fileBasename = path.basename(absoluteInputFile, path.extname(inputFile));\n            options.output = path.join(outputDir, `${fileBasename}.srt`);\n        } else {\n            options.output = path.resolve(options.output);\n        }\n\n        if (options.teleprompt) {\n            options.teleprompt = path.resolve(options.teleprompt);\n        }\n    });\n\nexport function parseArgs(): Args {\n    program.parse();\n    const opts = program.opts() as any;\n\n    return {\n        videoInputFile: program.args[0],\n        srtOutputFile: opts.output,\n        teleprompterFile: opts.teleprompt,\n        locale: opts.locale,\n        maxWordsPerCaption: opts.length,\n        splitBySentences: opts.sentences,\n        splitByClauses: opts.clauses,\n        karaokeEnabled: opts.karaoke,\n    };\n}","import ffmpeg, {setFfmpegPath} from 'fluent-ffmpeg';\n\n(() => {\n    try {\n        const ffmpegInstaller = require('@ffmpeg-installer/ffmpeg');\n        setFfmpegPath(ffmpegInstaller!.path);\n    } catch (error) {\n        console.warn('Impossible to install FFMpeg. Use system-provided ffmpeg.');\n    }\n})();\n\nexport async function extractAudio(videoInputFile: string, audioOutputFile: string) {\n    console.log(`Extracting audio into ${audioOutputFile}...`);\n\n    await new Promise((resolve, reject) => {\n        ffmpeg()\n            .input(videoInputFile)\n            .output(audioOutputFile)\n            .on('end', () => {\n                console.log(`${audioOutputFile} extracted`);\n                resolve(audioOutputFile);\n            })\n            .on('error', (err: any) => {\n                reject(err);\n            })\n            .run();\n    });\n}","import * as path from 'path';\nimport {mkdirSync, existsSync, writeFileSync, readFileSync} from 'fs';\nimport {SyncPrerecordedResponse} from '@deepgram/sdk';\n\nconst outDir = path.join(__dirname, '..', 'out');\n\nexport class WorkDir {\n    private readonly workDir: string;\n\n    constructor(videoInputFile: string) {\n        const fileBasename = path.basename(videoInputFile);\n        this.workDir = path.join(outDir, fileBasename);\n\n        if (!existsSync(this.workDir)) {\n            mkdirSync(this.workDir);\n        }\n\n        if (!existsSync(this.transcriptionsDir)) {\n            mkdirSync(this.transcriptionsDir);\n        }\n    }\n\n    public get audioFile(): string {\n        return path.join(this.workDir, 'audio.wav');\n    }\n\n    public get teleprompterFile(): string {\n        return path.join(this.workDir, 'teleprompter.txt');\n    }\n\n    public get transcriptionsDir(): string {\n        return path.join(this.workDir, 'transcriptions');\n    }\n\n    public isTranscriptionExist(locale: string): boolean {\n        const transcriptionFile = this.transcriptionFile(locale);\n        return existsSync(transcriptionFile);\n    }\n\n    public saveTranscription(locale: string, transcription: SyncPrerecordedResponse) {\n        const transcriptionFile = this.transcriptionFile(locale);\n        writeFileSync(transcriptionFile, JSON.stringify(transcription, null, 2));\n    }\n\n    public loadExistingTranscription(locale: string): SyncPrerecordedResponse {\n        const transcriptionFile = this.transcriptionFile(locale);\n        return JSON.parse(readFileSync(transcriptionFile, 'utf-8'));\n    }\n\n    private transcriptionFile(locale: string): string {\n        return path.join(this.transcriptionsDir, `transcription.${locale}.json`);\n    }\n}","import {createClient, SyncPrerecordedResponse} from '@deepgram/sdk';\nimport {readFileSync} from 'fs';\nimport chalk from 'chalk';\n\nexport interface DeepgramWord {\n    word: string;\n    start: number;\n    end: number;\n    confidence: number;\n    punctuated_word?: string;\n    speaker?: number;\n    speaker_confidence?: number;\n    language?: string;\n}\n\nexport async function transcribeFile(audioFile: string, locale: string): Promise<SyncPrerecordedResponse> {\n    const deepgramApiKey = process.env['DEEPGRAM_API_KEY'];\n    if (!deepgramApiKey) {\n        throw new Error('Environment variable DEEPGRAM_API_KEY is missing.');\n    }\n\n    const deepgram = createClient(deepgramApiKey);\n\n    console.log('Start transcription...');\n\n    const { result, error } = await deepgram.listen.prerecorded.transcribeFile(\n        readFileSync(audioFile),\n        {\n            model: 'nova-2',\n            language: locale,\n            smart_format: true,\n            punctuate: true,\n            diarize: true,\n        }\n    );\n\n    if (error) {\n        throw error;\n    }\n\n    console.log('Transcription finished!');\n\n    return result;\n}\n\nexport function printTranscription(transcription: SyncPrerecordedResponse) {\n    const transcribedWords = transcription.results.channels[0].alternatives[0].words;\n\n    for (const word of transcribedWords) {\n        let coloredWord;\n\n        if (word.confidence > 0.8) {\n            coloredWord = chalk.green(word.punctuated_word);\n        } else if (word.confidence > 0.5) {\n            coloredWord = chalk.yellow(word.punctuated_word);\n        } else {\n            coloredWord = chalk.red(word.punctuated_word);\n        }\n\n        console.log(`${ chalk.blue(word.start) } -> ${ chalk.blue(word.end) }: ${ coloredWord }`);\n    }\n}","import {DeepgramWord} from './transcriber';\n\ninterface Caption {\n    start: string;\n    end: string;\n    word: string;\n}\n\nexport function generateCaptions(wordsClusters: DeepgramWord[][], karaoke = false): string {\n    const captions = wordsClusters\n        .map(cluster => cluster.map(deepgramWordToCaption));\n    return karaoke ? generateKaraoke(captions) : generateSimple(captions);\n}\n\nfunction generateSimple(clusters: Caption[][]): string {\n    let n = 1;\n\n    let allCaptions = '';\n\n    for (let cluster of clusters) {\n        const firstWord = cluster[0];\n        const lastWord = cluster[cluster.length - 1];\n        const captionWords = cluster.map(caption => caption.word).join(' ');\n\n        const captionStr = `${n}\\n${firstWord.start} --> ${lastWord.end}\\n${captionWords}\\n\\n`;\n        n++;\n\n        allCaptions += captionStr;\n    }\n\n    return allCaptions;\n}\n\nfunction generateKaraoke(clusters: Caption[][]): string {\n    let n = 1;\n\n    let allCaptions = '';\n\n    for (let cluster of clusters) {\n        for (let i = 0; i < cluster.length; i++) {\n            const caption = cluster[i];\n            let captionWords = '';\n\n            for (let j = 0; j < cluster.length; j++) {\n                captionWords += j === i\n                    ? `[${cluster[j].word}] `\n                    : `${cluster[j].word} `;\n            }\n\n            const captionStr = `${n}\\n${caption.start} --> ${caption.end}\\n${captionWords}\\n\\n`;\n            n++;\n\n            allCaptions += captionStr;\n        }\n    }\n\n    return allCaptions;\n}\n\nfunction deepgramWordToCaption(deepgramWord: DeepgramWord): Caption {\n    const startStr = secondsToTimecodes(deepgramWord.start);\n    const endStr = secondsToTimecodes(deepgramWord.end);\n\n    return {\n        start: startStr,\n        end: endStr,\n        word: deepgramWord.punctuated_word ?? deepgramWord.word,\n    };\n}\n\nexport function secondsToTimecodes(seconds: number): string {\n    const millis = Math.floor(seconds * 1000) % 1000;\n\n    const hours = Math.floor(seconds / 3600);\n    const remainingSecondsAfterHours = seconds % 3600;\n    const minutes = Math.floor(remainingSecondsAfterHours / 60);\n    const remainingSecondsAfterMinutes = remainingSecondsAfterHours % 60;\n    const wholeSeconds = Math.floor(remainingSecondsAfterMinutes);\n\n    const hh = String(hours).padStart(2, '0');\n    const mm = String(minutes).padStart(2, '0');\n    const ss = String(wholeSeconds).padStart(2, '0');\n    const sss = String(millis).padStart(3, '0');\n\n    return `${hh}:${mm}:${ss},${sss}`;\n}","export function asciiFolding(word: string): string {\n    return word\n        .normalize('NFD')                   // decomposes the letters and diacritics.\n        .replace(/\\p{Diacritic}/gu, '');    // removes all the diacritics.\n}\n\nexport function normalizeWord(word: string): string {\n    return asciiFolding(word)\n        .replace(/â€™/g, \"'\")                 // normalize apostrophes\n        .replaceAll(/[^\\w']/g, '')          // remove all punctuation\n        .toLowerCase();\n}\n\nexport function endsWithPunctuation(word: string): boolean {\n    return !!asciiFolding(word).match(/[^\\w']$/);\n}\n\nexport function removePunctuation(tokens: string[]) {\n    return tokens.filter(token => !token.match(/^[,;.:!?]$/));\n}","import * as diff from 'fast-array-diff';\nimport {DeepgramWord} from './transcriber';\nimport {normalizeWord, removePunctuation} from './nlp';\nimport nlp from 'compromise';\n\ntype Token = DeepgramWord | string;\n\nfunction compare(transcriptionWord: Token, teleprompterToken: Token): boolean {\n    const normalizedTranscriptionWord = normalizeWord((transcriptionWord as DeepgramWord).word!);\n    const normalizedTeleprompterToken = normalizeWord(teleprompterToken as string);\n\n    return normalizedTranscriptionWord === normalizedTeleprompterToken;\n}\n\nfunction avgWordDurationSec(transcribedWords: DeepgramWord[]): number {\n    return transcribedWords\n        .map(word => word.end - word.start)\n        .reduce((total, curr) => total + curr) / transcribedWords.length;\n}\n\nexport class Corrector {\n    private readonly teleprompterTokens: string[];\n\n    constructor(teleprompterText: string) {\n        const doc = nlp(teleprompterText);\n        this.teleprompterTokens = removePunctuation(doc.terms().out('array'));\n    }\n\n    public correct(transcribedWords: DeepgramWord[]): DeepgramWord[] {\n        const same = diff.same(transcribedWords, this.teleprompterTokens, compare);\n        const similarity = same.length / this.teleprompterTokens.length * 100;\n\n        console.log(`Similarity: ${similarity}%`);\n\n        let patch = diff.getPatch(transcribedWords as Token[], this.teleprompterTokens as Token[], compare);\n        patch = Corrector.handleReplacements(patch);\n        const patched: Token[] = diff.applyPatch(transcribedWords as Token[], patch);\n\n        const avgWordDuration = avgWordDurationSec(transcribedWords);\n        return Corrector.ajustDurationOfInsertedWords(patched, avgWordDuration);\n    }\n\n    private static handleReplacements(patch: diff.Patch<Token>): diff.Patch<Token> {\n        for (let i = 0; i < patch.length; i++) {\n            const currentOp = patch[i];\n            const precOp: diff.PatchItem<Token> | null = i ? patch[i - 1] : null;\n\n            if (currentOp.type === 'add' && precOp?.type === 'remove') {\n                // This is replacement\n                let adjustedWords: DeepgramWord[];\n\n                if (currentOp.items.length === precOp.items.length) {\n                    // Use the start and the end of every word individually\n                    adjustedWords = [];\n                    for (let j = 0; j < currentOp.items.length; j++) {\n                        const newWord = currentOp.items[j] as string;\n                        const replacedWord = precOp.items[j] as DeepgramWord;\n                        adjustedWords.push({\n                            word: newWord,\n                            punctuated_word: newWord,\n                            start: replacedWord.start,\n                            end: replacedWord.end,\n                            confidence: 1,\n                        });\n                    }\n                } else {\n                    const startTime = (precOp.items[0] as DeepgramWord).start;\n                    const endTime = (precOp.items[precOp.items.length - 1] as DeepgramWord).end;\n                    adjustedWords = Corrector.adjustWords(currentOp.items as string[], startTime, endTime);\n                }\n\n                currentOp.items = adjustedWords;\n            }\n        }\n\n        return patch;\n    }\n\n    private static ajustDurationOfInsertedWords(patchedTokens: Token[], avgWordDuration: number): DeepgramWord[] {\n        const result: DeepgramWord[] = [];\n\n        let segmentStart: number | null = null;\n        let segmentEnd: number | null = null;\n\n        for (let i = 0; i < patchedTokens.length; i++) {\n            if (typeof patchedTokens[i] === 'string' && segmentStart === null) {\n                // Beginning of adjusted segment\n                segmentStart = i;\n            } else if (typeof patchedTokens[i] != 'string' && segmentStart != null) {\n                // Adjusted segment finished\n                segmentEnd = i - 1;\n                const wordsToAdjust: string[] = patchedTokens.slice(segmentStart, i) as string[];\n                const currentToken = patchedTokens[i] as DeepgramWord;\n\n                if (segmentStart === 0) {\n                    // Inserted at the beginning of transcription\n                    const nbInserted = segmentEnd - segmentStart + 1;\n                    const segmentDuration = nbInserted * avgWordDuration;\n                    const segmentStartTime = Math.max(currentToken.start - segmentDuration, 0);\n                    const segmentEndTime = currentToken.start;\n                    const adjustedWords = Corrector.adjustWords(wordsToAdjust, segmentStartTime, segmentEndTime);\n                    result.push(...adjustedWords);\n\n                    // Add current element to the result\n                    result.push(currentToken);\n                } else {\n                    // Insert in the middle of transcription\n                    const lastAsjustedWord = result.pop()!;\n                    const wordsToReadjust: string[] = [\n                        lastAsjustedWord.punctuated_word || lastAsjustedWord.word,\n                        ...wordsToAdjust,\n                        currentToken.punctuated_word || currentToken.word\n                    ];\n                    const segmentStartTime = lastAsjustedWord.start\n                    const segmentEndTime = currentToken.end;\n                    const adjustedWords = Corrector.adjustWords(wordsToReadjust, segmentStartTime, segmentEndTime);\n                    result.push(...adjustedWords);\n                }\n\n                // Reset adjusted segment\n                segmentStart = null;\n                segmentEnd = null;\n            } else if (typeof patchedTokens[i] != 'string') {\n                // Add current element to the result\n                result.push(patchedTokens[i] as DeepgramWord);\n            }\n        }\n\n        if (segmentStart != null && result.length) {\n            // Insert in the end\n            const wordsToAdjust: string[] = patchedTokens.slice(segmentStart) as string[];\n            const lastAsjustedWord = result[result.length - 1];\n            const segmentStartTime = lastAsjustedWord.start;\n            const segmentEndTime = segmentStartTime + wordsToAdjust.length * avgWordDuration;\n            const adjustedWords = Corrector.adjustWords(wordsToAdjust, segmentStartTime, segmentEndTime);\n            result.push(...adjustedWords);\n        }\n\n        return result;\n    }\n\n    private static adjustWords(words: string[], startTime: number, endTime: number): DeepgramWord[] {\n        const segmentDuration = endTime - startTime;\n        const durationPerInsertedWord = segmentDuration / words.length;\n\n        let time = startTime;\n        const adjustedWords: DeepgramWord[] = [];\n\n        for (let i = 0; i < words.length; i++) {\n            const word = words[i];\n            const isLastWord = i === words.length - 1;\n\n            const deepgramWord: DeepgramWord = {\n                word: word,\n                punctuated_word: word,\n                confidence: 1,\n                start: time,\n                end: isLastWord ? endTime : time += durationPerInsertedWord,\n            };\n            adjustedWords.push(deepgramWord);\n        }\n\n        return adjustedWords;\n    }\n}","import chalk from 'chalk';\nimport {DeepgramWord} from './transcriber';\n\nexport function validateWordsSpans(words: DeepgramWord[]) {\n    const startBeforePrecedentIndices: number[] = [];\n\n    for (let i = 1; i < words.length; i++) {\n        const word = words[i];\n        const precedentWord = words[i - 1];\n\n        if (word.start < precedentWord.end) {\n            startBeforePrecedentIndices.push(i);\n        }\n    }\n\n    if (!startBeforePrecedentIndices.length) {\n        console.log(chalk.green('All words are spanned correctly.'));\n    } else {\n        console.log(chalk.yellow('Followed words are spanned incorrectly:'));\n        for (const i of startBeforePrecedentIndices) {\n            const word = words[i];\n            const precedentWord = words[i - 1];\n\n            console.log(chalk.grey('...'));\n            console.log(`${ chalk.blue(precedentWord.start) } -> ${ chalk.blue(precedentWord.end) }: ${ chalk.green(precedentWord.punctuated_word) }`);\n            console.log(`${ chalk.blue(word.start) } -> ${ chalk.blue(word.end) }: ${ chalk.yellow(word.punctuated_word) }`);\n        }\n    }\n}","import {WordsClusterer} from './words-clusterer';\nimport {DeepgramWord} from '../transcriber';\nimport nlp from 'compromise';\n\nexport class ClausesWordsClusterer implements WordsClusterer {\n    cluster(deepgramWords: DeepgramWord[]): DeepgramWord[][] {\n        const recognizedText = deepgramWords\n            .map(word => word.punctuated_word)\n            .join(' ');\n        const doc = nlp(recognizedText);\n        const clauses = doc.clauses().out('array');\n\n        const clusters: DeepgramWord[][] = [];\n\n        for (const clause of clauses) {\n            const wordCount = clause.split(' ').length\n            clusters.push(deepgramWords.splice(0, wordCount));\n        }\n\n        return clusters;\n    }\n}","import { DeepgramWord } from '../transcriber';\nimport {WordsClusterer} from './words-clusterer';\nimport nlp from 'compromise';\n\nexport class SentencesWordsClusterer implements WordsClusterer {\n    cluster(deepgramWords: DeepgramWord[]): DeepgramWord[][] {\n        const recognizedText = deepgramWords\n            .map(word => word.punctuated_word)\n            .join(' ');\n        const doc = nlp(recognizedText);\n        const sentences = doc.sentences().out('array');\n\n        const clusters: DeepgramWord[][] = [];\n\n        for (const sentence of sentences) {\n            const wordCount = sentence.split(' ').length\n            clusters.push(deepgramWords.splice(0, wordCount));\n        }\n\n        return clusters;\n    }\n}","import {WordsClusterer} from './words-clusterer';\nimport {DeepgramWord} from '../transcriber';\nimport {endsWithPunctuation} from '../nlp';\n\nexport class MaxLengthWordsClusterer implements WordsClusterer {\n    public constructor(private readonly maxWordsPerCaption: number) {\n    }\n\n    public cluster(deepgramWords: DeepgramWord[]): DeepgramWord[][] {\n        let clusters: DeepgramWord[][] = [];\n        let lastWord: DeepgramWord | null = null;\n        let lastCluster: DeepgramWord[] | null = null;\n\n        for (let word of deepgramWords) {\n            const wordCount = lastCluster?.length || 0;\n\n            if (word.start === lastWord?.end\n                && wordCount < this.maxWordsPerCaption\n                && !endsWithPunctuation(lastWord.word)) {\n                lastCluster!.push(word);\n            } else {\n                lastCluster = [];\n                lastCluster.push(word);\n                clusters.push(lastCluster);\n            }\n\n            lastWord = word;\n        }\n\n        return clusters;\n    }\n}","import {DeepgramWord} from '../transcriber';\nimport {Args} from '../cli';\nimport {ClausesWordsClusterer} from './clauses-words-clusterer';\nimport {SentencesWordsClusterer} from './sentences-words-clusterer';\nimport {MaxLengthWordsClusterer} from './max-length-words-clusterer';\n\nexport interface WordsClusterer {\n    cluster(deepgramWords: DeepgramWord[]): DeepgramWord[][];\n}\n\nexport function createWordsClusterer(cliArgs: Args): WordsClusterer {\n    if (cliArgs.splitByClauses) {\n        return new ClausesWordsClusterer();\n    } else if (cliArgs.splitBySentences) {\n        return new SentencesWordsClusterer();\n    } else {\n        return new MaxLengthWordsClusterer(cliArgs.maxWordsPerCaption);\n    }\n}","import {parseArgs} from './cli';\nimport {extractAudio} from './audio-extractor';\nimport {WorkDir} from './work-dir';\nimport {cpSync, writeFileSync, readFileSync} from 'fs';\nimport {transcribeFile} from './transcriber';\nimport {generateCaptions} from './captions';\nimport {Corrector} from './corrector';\nimport chalk from 'chalk';\nimport {validateWordsSpans} from './words-spans-validator';\nimport {createWordsClusterer} from './nlp/words-clusterer';\n\nconst cliArgs = parseArgs();\nconst workDir = new WorkDir(cliArgs.videoInputFile);\n\n(async () => {\n    try {\n        console.log(chalk.magenta('Transcriptionist starting transcription'));\n\n        // Extract audio\n        console.log(chalk.yellow('Step 1:') + ' ' + chalk.blue('Extract audio'));\n        await extractAudio(cliArgs.videoInputFile, workDir.audioFile);\n\n        // Copy teleprompter text file\n        if (cliArgs.teleprompterFile) {\n            console.log(chalk.yellow('Step 2:') + ' ' + chalk.blue('Copy teleprompter text file'));\n            cpSync(cliArgs.teleprompterFile, workDir.teleprompterFile);\n        } else {\n            console.log(chalk.yellow('Step 2:') + ' ' + chalk.blue('Teleprompter text file not provided (do nothing)'));\n        }\n\n        // Transcribe audio\n        let transcription;\n        if (!workDir.isTranscriptionExist(cliArgs.locale)) {\n            console.log(chalk.yellow('Step 3:') + ' ' + chalk.blue('Transcribing audio'));\n            transcription = await transcribeFile(workDir.audioFile, cliArgs.locale);\n            workDir.saveTranscription(cliArgs.locale, transcription);\n        } else {\n            console.log(chalk.yellow('Step 3:') + ' ' + chalk.blue(`Transcription for locale '${cliArgs.locale}' already exists. (do nothing)`));\n            transcription = workDir.loadExistingTranscription(cliArgs.locale);\n        }\n\n        // Get transcription words\n        let transcribedWords = transcription.results.channels[0].alternatives[0].words;\n\n        // Correct words\n        if (cliArgs.teleprompterFile) {\n            console.log(chalk.yellow('Step 4:') + ' ' + chalk.blue('Correcting transcription with the help of teleprompter text file'));\n            const teleprompterText = readFileSync(workDir.teleprompterFile, 'utf-8');\n            const corrector = new Corrector(teleprompterText);\n            transcribedWords = corrector.correct(transcribedWords);\n        } else {\n            console.log(chalk.yellow('Step 4:') + ' ' + chalk.blue('Teleprompter text file not provided (do nothing)'));\n        }\n\n        // Validate words spans\n        console.log(chalk.yellow('Step 5:') + ' ' + chalk.blue('Validate words spans'));\n        validateWordsSpans(transcribedWords);\n\n        // Generate captions\n        console.log(chalk.yellow('Step 6:') + ' ' + chalk.blue('Generating captions'));\n        const wordsClusterer = createWordsClusterer(cliArgs);\n        const wordsClusters = wordsClusterer.cluster(transcribedWords);\n        const captionsText = generateCaptions(wordsClusters, cliArgs.karaokeEnabled);\n        writeFileSync(cliArgs.srtOutputFile, captionsText);\n\n        console.log(chalk.green('Success:') + ' ' + `Captions written into ${cliArgs.srtOutputFile}`);\n    } catch (err) {\n        console.error(chalk.red('Error occurred:'), err);\n    }\n})();"],"names":["program","path","setFfmpegPath","existsSync","mkdirSync","writeFileSync","readFileSync","createClient","diff","cpSync"],"mappings":"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","x_google_ignoreList":[0,1]}