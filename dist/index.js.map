{"version":3,"file":"index.js","sources":["../node_modules/@commander-js/extra-typings/index.js","../node_modules/@commander-js/extra-typings/esm.mjs","../src/cli.ts","../src/audio-extractor.ts","../src/work-dir.ts","../src/transcriber.ts","../src/captions.ts","../src/corrector.ts","../src/index.ts"],"sourcesContent":["const commander = require('commander');\n\nexports = module.exports = {};\n\n// Return a different global program than commander,\n// and don't also return it as default export.\nexports.program = new commander.Command();\n\n/**\n * Expose classes. The FooT versions are just types, so return Commander original implementations!\n */\n\nexports.Argument = commander.Argument;\nexports.Command = commander.Command;\nexports.CommanderError = commander.CommanderError;\nexports.Help = commander.Help;\nexports.InvalidArgumentError = commander.InvalidArgumentError;\nexports.InvalidOptionArgumentError = commander.InvalidArgumentError; // Deprecated\nexports.Option = commander.Option;\n\n// In Commander, the create routines end up being aliases for the matching\n// methods on the global program due to the (deprecated) legacy default export.\n// Here we roll our own, the way Commander might in future.\nexports.createCommand = (name) => new commander.Command(name);\nexports.createOption = (flags, description) =>\n  new commander.Option(flags, description);\nexports.createArgument = (name, description) =>\n  new commander.Argument(name, description);\n","import extraTypingsCommander from './index.js';\n\n// wrapper to provide named exports for ESM.\nexport const {\n  program,\n  createCommand,\n  createArgument,\n  createOption,\n  CommanderError,\n  InvalidArgumentError,\n  InvalidOptionArgumentError, // deprecated old name\n  Command,\n  Argument,\n  Option,\n  Help,\n} = extraTypingsCommander;\n","import * as path from 'path';\nimport {Command} from '@commander-js/extra-typings';\nimport packageJson from '../package.json';\n\nexport interface Args {\n    videoInputFile: string;\n    srtOutputFile: string;\n    teleprompterFile?: string\n    locale: string;\n}\n\nfunction assertFileExtension(ext: string): (v: string) => void {\n    return (value: string) => {\n        if (!value.endsWith(ext)) {\n            throw new Error(`File should have extension ${ext}!`);\n        }\n        return value;\n    };\n}\n\nconst program = new Command();\n\nprogram\n    .name('transcribe')\n    .description('Tool to transcribe videos using AI.')\n    .version(packageJson.version)\n    .argument('<file>', 'Path to the original video file.')\n    .option('-o, --output <file>',\n        `Full or relative path where the created SubRip Subtitle (.srt) file should be written.\n        By default, it will be saved in the same directory as the input video file.`,\n        assertFileExtension('.srt'))\n    .option('-t, --teleprompt <file>',\n        `Full or relative path to teleprompter text (.txt) file.\n        If not provided, transcription will not be corrected.`,\n        assertFileExtension('.txt'))\n    .option('-l, --locale <string>',\n        'Locale that will be used to transcribe the video (default: en-US).',\n        'en-US')\n    .action((inputFile, options: any) => {\n        const absoluteInputFile = path.resolve(inputFile);\n        program.args[0] = absoluteInputFile;\n\n        if (!options.output) {\n            const outputDir = path.dirname(absoluteInputFile);\n            const fileBasename = path.basename(absoluteInputFile, path.extname(inputFile));\n            options.output = path.join(outputDir, `${fileBasename}.srt`);\n        } else {\n            options.output = path.resolve(options.output);\n        }\n\n        if (options.teleprompt) {\n            options.teleprompt = path.resolve(options.teleprompt);\n        }\n    });\n\nexport function parseArgs(): Args {\n    program.parse();\n    const opts = program.opts() as any;\n\n    return {\n        videoInputFile: program.args[0],\n        srtOutputFile: opts.output,\n        teleprompterFile: opts.teleprompt,\n        locale: opts.locale,\n    };\n}","import ffmpeg from 'fluent-ffmpeg';\n\nexport async function extractAudio(videoInputFile: string, audioOutputFile: string) {\n    console.log(`Extracting audio into ${audioOutputFile}...`);\n\n    await new Promise((resolve, reject) => {\n        ffmpeg()\n            .input(videoInputFile)\n            .output(audioOutputFile)\n            .on('end', () => {\n                console.log(`${audioOutputFile} extracted`);\n                resolve(audioOutputFile);\n            })\n            .on('error', (err: any) => {\n                reject(err);\n            })\n            .run();\n    });\n}","import * as path from 'path';\nimport {mkdirSync, existsSync, writeFileSync, readFileSync} from 'fs';\nimport {SyncPrerecordedResponse} from '@deepgram/sdk';\n\nconst outDir = path.join(__dirname, '..', 'out');\n\nexport class WorkDir {\n    private readonly workDir: string;\n\n    constructor(private readonly videoInputFile: string) {\n        const fileBasename = path.basename(videoInputFile);\n        this.workDir = path.join(outDir, fileBasename);\n\n        if (!existsSync(this.workDir)) {\n            mkdirSync(this.workDir);\n        }\n\n        if (!existsSync(this.transcriptionsDir)) {\n            mkdirSync(this.transcriptionsDir);\n        }\n    }\n\n    public get copiedVideoFile(): string {\n        const ext = path.extname(this.videoInputFile);\n        return path.join(this.workDir, `original.${ext}`);\n    }\n\n    public get audioFile(): string {\n        return path.join(this.workDir, 'audio.wav');\n    }\n\n    public get teleprompterFile(): string {\n        return path.join(this.workDir, 'teleprompter.txt');\n    }\n\n    public get transcriptionsDir(): string {\n        return path.join(this.workDir, 'transcriptions');\n    }\n\n    public isTranscriptionExist(locale: string): boolean {\n        const transcriptionFile = this.transcriptionFile(locale);\n        return existsSync(transcriptionFile);\n    }\n\n    public saveTranscription(locale: string, transcription: SyncPrerecordedResponse) {\n        const transcriptionFile = this.transcriptionFile(locale);\n        writeFileSync(transcriptionFile, JSON.stringify(transcription, null, 2));\n    }\n\n    public loadExistingTranscription(locale: string): SyncPrerecordedResponse {\n        const transcriptionFile = this.transcriptionFile(locale);\n        return JSON.parse(readFileSync(transcriptionFile, 'utf-8'));\n    }\n\n    private transcriptionFile(locale: string): string {\n        return path.join(this.transcriptionsDir, `transcription.${locale}.json`);\n    }\n}","import {createClient, SyncPrerecordedResponse} from '@deepgram/sdk';\nimport {readFileSync} from 'fs';\n\nexport interface DeepgramWord {\n    word: string;\n    start: number;\n    end: number;\n    confidence: number;\n    punctuated_word?: string;\n    speaker?: number;\n    speaker_confidence?: number;\n    language?: string;\n}\n\nexport async function transcribeFile(audioFile: string, locale: string): Promise<SyncPrerecordedResponse> {\n    const deepgramApiKey = process.env['DEEPGRAM_API_KEY'];\n    if (!deepgramApiKey) {\n        throw new Error('Environment variable DEEPGRAM_API_KEY is missing.');\n    }\n\n    const deepgram = createClient(deepgramApiKey);\n\n    console.log('Start transcription...');\n\n    const { result, error } = await deepgram.listen.prerecorded.transcribeFile(\n        readFileSync(audioFile),\n        {\n            model: 'nova-2',\n            language: locale,\n            smart_format: true,\n            punctuate: true,\n            diarize: true,\n        }\n    );\n\n    if (error) {\n        throw error;\n    }\n\n    console.log('Transcription finished!');\n\n    return result;\n}","import {DateTime} from 'luxon';\nimport {DeepgramWord} from './transcriber';\n\nconst wordsPerCluster = 5;\n\ninterface Caption {\n    start: string;\n    end: string;\n    word: string;\n}\n\nexport function generateCaptions(deepgramWords: DeepgramWord[]): string {\n    let clusters: Caption[][] = [];\n    let lastCaption: Caption | null = null;\n    let lastCluster: Caption[] | null = null;\n\n    for (let word of deepgramWords) {\n        const newCaption = deepgramWordToCaption(word);\n\n        const wordCount = lastCluster?.length || 0;\n\n        if (newCaption.start === lastCaption?.end && wordCount < wordsPerCluster) {\n            lastCluster!.push(newCaption);\n        } else {\n            lastCluster = [];\n            lastCluster.push(newCaption);\n            clusters.push(lastCluster);\n        }\n\n        lastCaption = newCaption;\n    }\n\n    let n = 1;\n\n    let allCaptions = '';\n\n    for (let cluster of clusters) {\n        for (let i = 0; i < cluster.length; i++) {\n            const caption = cluster[i];\n            let captionWords = '';\n\n            for (let j = 0; j < cluster.length; j++) {\n                captionWords += j === i\n                    ? `[${cluster[j].word}] `\n                    : `${cluster[j].word} `;\n            }\n\n            const captionStr = `${n}\\n${caption.start} --> ${caption.end}\\n${captionWords}\\n\\n`;\n            n++;\n\n            allCaptions += captionStr;\n        }\n    }\n\n    return allCaptions;\n}\n\nfunction deepgramWordToCaption(deepgramWord: DeepgramWord): Caption {\n    const startStr = secondsToTimecodes(deepgramWord.start);\n    const endStr = secondsToTimecodes(deepgramWord.end);\n\n    return {\n        start: startStr,\n        end: endStr,\n        word: deepgramWord.punctuated_word!,\n    };\n}\n\nfunction secondsToTimecodes(seconds: number): string {\n    return DateTime\n        .fromSeconds(seconds, { zone: 'utc' }).\n        toFormat('HH:mm:ss.SSS');\n}","import * as natural from 'natural';\nimport * as diff from 'fast-array-diff';\nimport {DeepgramWord} from './transcriber';\n\ntype Token = DeepgramWord | string;\n\nfunction normalizeWord(word: string): string {\n    return word\n        .normalize('NFD')                   // decomposes the letters and diacritics.\n        .replace(/\\p{Diacritic}/gu, '')     // removes all the diacritics.\n        .replaceAll(/[^\\w']/g, '')          // remove all punctuation\n        .toLowerCase();\n}\n\nfunction compare(transcriptionWord: Token, teleprompterToken: Token): boolean {\n    const normalizedTranscriptionWord = normalizeWord((transcriptionWord as DeepgramWord).punctuated_word!);\n    const normalizedTeleprompterToken = normalizeWord(teleprompterToken as string);\n\n    return normalizedTranscriptionWord === normalizedTeleprompterToken;\n}\n\nfunction avgWordDurationSec(transcribedWords: DeepgramWord[]): number {\n    return transcribedWords\n        .map(word => word.end - word.start)\n        .reduce((total, curr) => total + curr) / transcribedWords.length;\n}\n\n/**\n * Attaches punctuation signs to the previous word.\n * @param tokens  word tokens\n */\nfunction collapsePunctuation(tokens: string[]) {\n    const res = [];\n\n    for (const token of tokens) {\n        if (token.match(/[A-Za-zÀ-ÖØ-öø-ÿ]/)) {\n            res.push(token);\n        } else {\n            res[res.length - 1] += ` ${token}`;\n        }\n    }\n\n    return res;\n}\n\nexport class Corrector {\n    private readonly tokenizer = new natural.RegexpTokenizer({ pattern: /\\s+/ });\n    private readonly teleprompterTokens: string[];\n\n    constructor(teleprompterText: string) {\n        this.teleprompterTokens = collapsePunctuation(this.tokenizer.tokenize(teleprompterText));\n    }\n\n    public correct(transcribedWords: DeepgramWord[]): DeepgramWord[] {\n        const same = diff.same(transcribedWords, this.teleprompterTokens, compare);\n        const similarity = same.length / this.teleprompterTokens.length * 100;\n\n        console.log(`Similarity: ${similarity}%`);\n\n        const patch = diff.getPatch(transcribedWords as Token[], this.teleprompterTokens as Token[], compare);\n        const patched: Token[] = diff.applyPatch(transcribedWords as Token[], patch);\n\n        const avgWordDuration = avgWordDurationSec(transcribedWords);\n        return Corrector.ajustDurationOfInsertedWords(patched, avgWordDuration);\n    }\n\n    private static ajustDurationOfInsertedWords(patchedTokens: Token[], avgWordDuration: number): DeepgramWord[] {\n        const result: DeepgramWord[] = [];\n\n        let segmentStart: number | null = null;\n        let segmentEnd: number | null = null;\n\n        for (let i = 0; i < patchedTokens.length; i++) {\n            if (typeof patchedTokens[i] === 'string' && segmentStart === null) {\n                // Beginning of adjusted segment\n                segmentStart = i;\n            } else if (typeof patchedTokens[i] != 'string' && segmentStart != null) {\n                // Adjusted segment finished\n                segmentEnd = i - 1;\n                const wordsToAdjust: string[] = patchedTokens.slice(segmentStart, i) as string[];\n                const currentToken = patchedTokens[i] as DeepgramWord;\n\n                if (segmentStart === 0) {\n                    // Inserted at the beginning of transcription\n                    const nbInserted = segmentEnd - segmentStart + 1;\n                    const segmentDuration = nbInserted * avgWordDuration;\n                    const segmentStartTime = Math.max(currentToken.start - segmentDuration, 0);\n                    const segmentEndTime = currentToken.start;\n                    const adjustedWords = Corrector.adjustWords(wordsToAdjust, segmentStartTime, segmentEndTime);\n                    result.push(...adjustedWords);\n                } else {\n                    // Insert in the middle of transcription\n                    const lastAsjustedWord = result.pop()!;\n                    const wordsToReadjust: string[] = [\n                        lastAsjustedWord.punctuated_word || lastAsjustedWord.word,\n                        ...wordsToAdjust,\n                        currentToken.punctuated_word || currentToken.word\n                    ];\n                    const segmentStartTime = lastAsjustedWord.start\n                    const segmentEndTime = currentToken.end;\n                    const adjustedWords = Corrector.adjustWords(wordsToReadjust, segmentStartTime, segmentEndTime);\n                    result.push(...adjustedWords);\n                }\n\n                // Reset adjusted segment\n                segmentStart = null;\n                segmentEnd = null;\n\n                // Add current element to the result\n                result.push(patchedTokens[i] as DeepgramWord);\n            } else if (typeof patchedTokens[i] != 'string') {\n                // Add current element to the result\n                result.push(patchedTokens[i] as DeepgramWord);\n            }\n        }\n\n        if (segmentStart != null && result.length) {\n            // Insert in the end\n            const wordsToAdjust: string[] = patchedTokens.slice(segmentStart) as string[];\n            const lastAsjustedWord = result[result.length - 1];\n            const segmentStartTime = lastAsjustedWord.start;\n            const segmentEndTime = segmentStartTime + wordsToAdjust.length * avgWordDuration;\n            const adjustedWords = Corrector.adjustWords(wordsToAdjust, segmentStartTime, segmentEndTime);\n            result.push(...adjustedWords);\n        }\n\n        return result;\n    }\n\n    private static adjustWords(words: string[], startTime: number, endTime: number): DeepgramWord[] {\n        const segmentDuration = endTime - startTime;\n        const durationPerInsertedWord = segmentDuration / words.length;\n\n        let time = startTime;\n        const adjustedWords: DeepgramWord[] = [];\n\n        for (const word of words) {\n            const deepgramWord: DeepgramWord = {\n                word: word,\n                punctuated_word: word,\n                start: time,\n                end: (time += durationPerInsertedWord),\n                confidence: 1,\n            };\n            adjustedWords.push(deepgramWord);\n        }\n\n        return adjustedWords;\n    }\n}","import {parseArgs} from './cli';\nimport {extractAudio} from './audio-extractor';\nimport {WorkDir} from './work-dir';\nimport {cpSync, writeFileSync, readFileSync} from 'fs';\nimport {transcribeFile} from './transcriber';\nimport {generateCaptions} from './captions';\nimport {Corrector} from './corrector';\nimport chalk from 'chalk';\n\nconst cliArgs = parseArgs();\n\nconst workDir = new WorkDir(cliArgs.videoInputFile);\n\n(async () => {\n    try {\n        console.log(chalk.magenta('Transcriptionist starting transcription'));\n\n        // Copy original video file\n        console.log(chalk.yellow('Step 1:') + ' ' + chalk.blue('Copy original video file'));\n        cpSync(cliArgs.videoInputFile, workDir.copiedVideoFile);\n\n        // Copy teleprompter text file\n        if (cliArgs.teleprompterFile) {\n            console.log(chalk.yellow('Step 2:') + ' ' + chalk.blue('Copy teleprompter text file'));\n            cpSync(cliArgs.teleprompterFile, workDir.teleprompterFile);\n        } else {\n            console.log(chalk.yellow('Step 2:') + ' ' + chalk.blue('Teleprompter text file not provided (do nothing)'));\n        }\n\n        // Extract audio\n        console.log(chalk.yellow('Step 3:') + ' ' + chalk.blue('Extract audio'));\n        await extractAudio(workDir.copiedVideoFile, workDir.audioFile);\n\n        // Transcribe audio\n        let transcription;\n        if (!workDir.isTranscriptionExist(cliArgs.locale)) {\n            console.log(chalk.yellow('Step 4:') + ' ' + chalk.blue('Transcribing audio'));\n            transcription = await transcribeFile(workDir.audioFile, cliArgs.locale);\n            workDir.saveTranscription(cliArgs.locale, transcription);\n        } else {\n            console.log(chalk.yellow('Step 4:') + ' ' + chalk.blue(`Transcription for locale '${cliArgs.locale}' already exists. (do nothing)`));\n            transcription = workDir.loadExistingTranscription(cliArgs.locale);\n        }\n\n        // Get transcription words\n        let transcribedWords = transcription.results.channels[0].alternatives[0].words;\n\n        // Correct words\n        if (cliArgs.teleprompterFile) {\n            console.log(chalk.yellow('Step 5:') + ' ' + chalk.blue('Correcting transcription with the help of teleprompter text file'));\n            const teleprompterText = readFileSync(workDir.teleprompterFile, 'utf-8');\n            const corrector = new Corrector(teleprompterText);\n            transcribedWords = corrector.correct(transcribedWords);\n        } else {\n            console.log(chalk.yellow('Step 5:') + ' ' + chalk.blue('Teleprompter text file not provided (do nothing)'));\n        }\n\n        // Generate captions\n        console.log(chalk.yellow('Step 6:') + ' ' + chalk.blue('Generating captions'));\n        const captionsText = generateCaptions(transcribedWords);\n        writeFileSync(cliArgs.srtOutputFile, captionsText);\n\n        console.log(chalk.green('Success:') + ' ' + `Captions written into ${cliArgs.srtOutputFile}`);\n    } catch (err) {\n        console.error(chalk.red('Error occurred:'), err);\n    }\n})();"],"names":["program","path","existsSync","mkdirSync","writeFileSync","readFileSync","createClient","DateTime","natural","diff","cpSync"],"mappings":"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","x_google_ignoreList":[0,1]}